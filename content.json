{"meta":{"title":"铅笔芯小屋","subtitle":null,"description":"天天开心","author":"一只铅笔芯","url":"https://github.com/penciy/penciy.github.io"},"pages":[{"title":"关于","date":"2019-12-31T16:00:00.000Z","updated":"2023-07-04T16:09:32.000Z","comments":false,"path":"about/index.html","permalink":"https://github.com/penciy/penciy.github.io/about/index.html","excerpt":"","text":"关于我我是一个在命运长河里挣扎的小鱼，90后，目前是小白一枚。虽然心中不甘，但是目前确实是 Worst One 。目标是成为全栈工程师、系统架构师。虽然前路迷茫，但是我会一步一步往前走。 关于主题Hexo - LiveForCode 主题是根据 BNDong 的博客样式复制过来的，其中也借鉴了 Hexo - NexT 主题的样式。可能这个主题还有很多不尽人意的地方，在后续的阶段我会不断地完善，如果有关于主题的相关问题，欢迎联系我。"},{"title":"标签","date":"2019-12-31T16:00:00.000Z","updated":"2023-07-04T16:09:32.000Z","comments":true,"path":"tag/index.html","permalink":"https://github.com/penciy/penciy.github.io/tag/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-12-31T16:00:00.000Z","updated":"2023-07-04T16:09:32.000Z","comments":true,"path":"category/index.html","permalink":"https://github.com/penciy/penciy.github.io/category/index.html","excerpt":"","text":""},{"title":"赞赏","date":"2019-12-31T16:00:00.000Z","updated":"2023-07-04T16:09:32.000Z","comments":false,"path":"donate/index.html","permalink":"https://github.com/penciy/penciy.github.io/donate/index.html","excerpt":"","text":"如果喜欢我的博客，或者喜欢我的博客主题，可以考虑赞赏一下哦，非常感激！网站所需的服务器和 CDN 都是不小的开支，日常维护也需要大量精力。 你们的支持是我前进的最大动力！"},{"title":"留言板","date":"2019-12-31T16:00:00.000Z","updated":"2023-07-04T16:09:32.000Z","comments":true,"path":"comment/index.html","permalink":"https://github.com/penciy/penciy.github.io/comment/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-12-31T16:00:00.000Z","updated":"2023-07-04T16:09:32.000Z","comments":false,"path":"friend/index.html","permalink":"https://github.com/penciy/penciy.github.io/friend/index.html","excerpt":"","text":"欢迎各位朋友前来交换友链，本站友链接受以下类型的网站： 个人博客 公益组织等非盈利性网站 不接受广告、商业性网站，特殊情况除外 如果你的网站 一个月以上无法正常访问 将会被移除。"}],"posts":[{"title":"Tarjan强连通分量、割点/割边","slug":"Tarjan强连通分量-割点-割边","date":"2024-04-12T12:19:32.000Z","updated":"2024-04-21T14:21:05.592Z","comments":true,"path":"posts/1828842990/","link":"","permalink":"https://github.com/penciy/penciy.github.io/posts/1828842990/","excerpt":"","text":"强连通分量定义强连通的定义是：有向图 G 强连通是指，G 中任意两个结点连通。强连通分量（Strongly Connected Components，SCC）的定义是：极大的强连通子图，即彼此两两可达的节点集合。如下图，强连通分量可以表示为[[2, 3, 4, 5], [1], [6, 8, 9], [7]]。 算法为每个节点维护两个变量： dfn：该节点被dfs最初访问到的时间 low：该节点能够通过其出边回溯到的最小时间 容易得到结论： 子树节点的dfn一定大于当前节点的dfn 从根节点开始的一条路径上，dfn严格递增，low严格非降 算法流程：按照深度优先搜索算法搜索的次序对图中所有的结点进行搜索，维护每个结点的 dfn 与 low 变量，且让搜索到的结点入栈。每当找到一个强连通元素，就按照该元素包含结点数目让栈中元素出栈。在搜索过程中，对于结点u和与其相邻的结点v(v不是u的父节点)考虑 3 种情况： v未被访问：继续对v进行深度搜索。在回溯过程中，用low[v]更新 low[u]。因为存在从u到v的直接路径，所以v能够回溯到的已经在栈中的结点，u也一定能够回溯到。 v被访问过，已经在栈中：根据 low 值的定义，用low[v]更新low[u] 。 v被访问过，已不在栈中：说明v已搜索完毕，其所在连通分量已被处理，所以不用对其做操作。 一个连通分量有且仅有一个节点的dfn等于low。该节点一定是在深度遍历的过程中，该连通分量中第一个被访问过的节点，因为它的 dfn 和 low 值最小，不会被该连通分量中的其他结点所影响。因此在回溯的过程中如果dfn == low，说明该节点及栈中节点构成一个SCC。注意如果原图并非无向连通图，需要在循环内多次调用tarjan，确保每个点都被访问到。 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344// Tarjan求强连通分量板子// 全局变量int time = 1; // 当前时间戳Deque&lt;Integer&gt; stk = new ArrayDeque&lt;&gt;();int[] dfn; // 某节点被dfs访问到的时间int[] low; // 某节点能通过其出边回溯到的最早时间boolean[] inStack; // 节点是否在栈中，用于处理存在自环且除自环外无出边的点public List&lt;List&lt;Integer&gt;&gt; tarjan(List&lt;Integer&gt;[] g)&#123; int n = g.length; dfn = new int[n]; low = new int[n]; inStack = new boolean[n]; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); for(int i = 0;i &lt; n;++i) if(dfn[i] == 0) dfs(g, i, ret); return ret;&#125; public void dfs(List&lt;Integer&gt;[] g, int cur, List&lt;List&lt;Integer&gt;&gt; ret)&#123; dfn[cur] = time; low[cur] = time; ++time; stk.push(cur); inStack[cur] = true; for(int nxt: g[cur])&#123; if(dfn[nxt] == 0) &#123; dfs(g, nxt, ret); low[cur] = Math.min(low[cur], low[nxt]); &#125; else if(inStack[nxt])&#123; low[cur] = Math.min(low[cur], low[nxt]); &#125; &#125; // 当节点的low与dfn相等，说明它无法回溯到更早的时间点，它就是一个强连通分量的顶点 if(low[cur] == dfn[cur])&#123; List&lt;Integer&gt; ls = new ArrayList&lt;&gt;(); int top = -1; do&#123; top = stk.pop(); ls.add(top); inStack[top] = false; &#125;while(top != cur); ret.add(ls); &#125;&#125; 时间复杂度：O(V+E) 注：Tarjan求强连通分量适用于有向图，无向图的连通分量直接用并查集就行。 题目802. 找到最终的安全状态 - 力扣（LeetCode）（本题Tarjan并非最优解法） 割点/割边定义割点：对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点。割边：对于一个无向图，如果删掉一条边后图中的连通分量数增加了，则称这条边为桥或者割边。 算法类似强连通分量。割点判据有两条：1.根节点且有至少两个子树；2.非根节点且存在一个儿子nxt满足low[nxt] &gt;= dfn[cur]。割边的判据只有一条：low[nxt] &gt; dfn[cur]，说明cur-nxt这条边是割边。 注意当发现已经访问过的节点时，需要用dfn[nxt]更新low[cur]，而不是像求解SCC时使用low[nxt]更新。考虑无向图结构如下，从节点1出发，如果使用的是low[nxt]更新，会导致节点5和节点6的low被更新为1，算法会认为节点5和6不需要经过节点2就能回溯到更早的节点，进而认为节点2不是割点。 也就是说更新low[cur]时不能通过nxt的其它边继续回溯。 模板适用于无向连通图 123456789101112131415161718192021222324252627282930313233343536373839404142434445int time = 1;int[] dfn;int[] low;List&lt;List&lt;Integer&gt;&gt; edges = new ArrayList&lt;&gt;();List&lt;Integer&gt; points = new ArrayList&lt;&gt;();Set&lt;Integer&gt; seenPoint = new HashSet&lt;&gt;();public void Tarjan(List&lt;Integer&gt;[] g)&#123; int n = g.length; dfn = new int[n]; low = new int[n]; dfs(g, 0, -1);&#125;public void dfs(List&lt;Integer&gt;[] g, int cur, int fa)&#123; dfn[cur] = time; low[cur] = time; time++; int sonCnt = 0; for(int nxt: g[cur])&#123; if(nxt == fa) continue; if(dfn[nxt] == 0)&#123; sonCnt++; dfs(g, nxt, cur); low[cur] = Math.min(low[cur], low[nxt]); // 割边判据1：low[nxt] &gt; dfn[cur]，则cur-nxt为割边 if(low[nxt] &gt; dfn[cur])&#123; List&lt;Integer&gt; edge = new ArrayList&lt;&gt;(); edge.add(cur); edge.add(nxt); edges.add(edge); &#125; // 割点判据1：cur非根节点，且存在一个孩子nxt满足low[nxt] &gt;= dfn[cur] if(seenPoint.contains(cur)) continue; if(fa != -1 &amp;&amp; low[nxt] &gt;= dfn[cur])&#123; points.add(cur); seenPoint.add(cur); &#125; &#125; else&#123; low[cur] = Math.min(low[cur], dfn[nxt]); // 注意这里不要用low[nxt]更新 &#125; // 割点判据2：cur为根节点，且存在至少两个子树 if(fa == -1 &amp;&amp; sonCnt &gt;= 2) points.add(cur); &#125;&#125; 缩点定义：把连通分量看成是一个大点，保留那些不在强连通分量里的边，这样的图就是缩点后的图。缩点后的图保留了所有不在分量里的边，而且对于有向连通图，缩点后的图是一个有向无环图(DAG)，可以进行拓扑排序。 题目1192. 查找集群内的关键连接 - 力扣（LeetCode）———-割边 1489. 找到最小生成树里的关键边和伪关键边 - 力扣（LeetCode）———-割边、缩点 注意本题在缩点后的图中，是可能存在重复边的，因此不能用父节点作为continue的依据，而应该使用来路的那条边作为continue的依据","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://github.com/penciy/penciy.github.io/tag/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://github.com/penciy/penciy.github.io/tag/%E5%9B%BE%E8%AE%BA/"}],"keywords":[]},{"title":"树上倍增+LCA问题","slug":"树上倍增+LCA问题","date":"2024-04-07T13:11:24.000Z","updated":"2024-04-21T14:20:57.220Z","comments":true,"path":"posts/4274956372/","link":"","permalink":"https://github.com/penciy/penciy.github.io/posts/4274956372/","excerpt":"","text":"树上倍增模板题：1483. 树节点的第 K 个祖先 - 力扣（LeetCode） 如果从某个节点出发，一步步往上跳，单次查询的时间复杂度为O(k)。可以预处理出一个pa数组，pa[i] [j]表示节点i的第2^j个祖先，注意预处理时外层循环为j，内层循环为i。在预处理后，就可以根据k的二进制形式，快速抵达第k个祖先。 树上倍增求解LCA问题： 预处理得到pa数组，pa[i] [j]表示节点i的第2^j个祖先; 求解x和y的最近公共祖先时，首先较深的节点(假设为y)转为与x相同的深度上，即y = getKthAncestor(depth[y] - depth[x])，如果此时x == y，那么x即为结果。 否则二者同步向上找，从节点数n的最高位开始遍历： 若pa[x] [i] == -1 || pa[x] [i] == pa[y] [i]，说明步子迈大了，继续循环 若pa[x] [i] != -1 &amp;&amp; pa[x] [i] != pa[y] [i]，说明lca还在上方，将x更新为 pa[x] [i] , y更新为 pa[y] [i]，将i减1继续循环。 上述做法能跳就尽量跳，不会错过任何可以上跳的机会。所以循环结束时，lca与x仅一步之遥。即lca = pa[x] [0]。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class TreeAncestor &#123; private int[] depth; private int[][] pa; public TreeAncestor(int[][] edges) &#123; int n = edges.length + 1; int m = 32 - Integer.numberOfLeadingZeros(n); // n 的二进制长度 List&lt;Integer&gt; g[] = new ArrayList[n]; Arrays.setAll(g, e -&gt; new ArrayList&lt;&gt;()); for (var e : edges) &#123; // 节点编号从 0 开始 int x = e[0], y = e[1]; g[x].add(y); g[y].add(x); &#125; depth = new int[n]; pa = new int[n][m]; dfs(g, 0, -1); for (int i = 0; i &lt; m - 1; i++) &#123; for (int x = 0; x &lt; n; x++) &#123; int p = pa[x][i]; pa[x][i + 1] = p &lt; 0 ? -1 : pa[p][i]; &#125; &#125; &#125; private void dfs(List&lt;Integer&gt;[] g, int x, int fa) &#123; pa[x][0] = fa; for (int y : g[x]) &#123; if (y != fa) &#123; depth[y] = depth[x] + 1; dfs(g, y, x); &#125; &#125; &#125; public int getKthAncestor(int node, int k) &#123; for (; k &gt; 0; k &amp;= k - 1) node = pa[node][Integer.numberOfTrailingZeros(k)]; return node; &#125; public int getLCA(int x, int y) &#123; if (depth[x] &gt; depth[y]) &#123; int tmp = y; y = x; x = tmp; &#125; // 使 y 和 x 在同一深度 y = getKthAncestor(y, depth[y] - depth[x]); if (y == x) return x; for (int i = pa[x].length - 1; i &gt;= 0; i--) &#123; int px = pa[x][i], py = pa[y][i]; if (px != py) &#123; x = px; y = py; &#125; &#125; return pa[x][0]; &#125;&#125; 时间复杂度：初始化O(NlogN), getLCA单次执行O(logN) 空间复杂度:O(NlogN) 题目：2846. 边权重均等查询 - 力扣（LeetCode）","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://github.com/penciy/penciy.github.io/tag/%E7%AE%97%E6%B3%95/"}],"keywords":[]},{"title":"二分查找","slug":"二分查找","date":"2024-04-03T11:51:33.000Z","updated":"2024-04-21T14:28:50.221Z","comments":true,"path":"posts/3907716225/","link":"","permalink":"https://github.com/penciy/penciy.github.io/posts/3907716225/","excerpt":"","text":"二分查找可以二分的前提：有序 时间复杂度：O(log n) 模板目前只遇到了两种二分情况，基本可以包括所有二分的情景： 前半段是false，后半段是true，查找最靠左的true 形如：false false false false true true true 实例：对于升序数组，查找第一个大于等于target的元素的下标 12345678int l = 0, r = n - 1;while(l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if(nums[mid] &gt;= target) r = mid - 1; else l = mid + 1;&#125;return l; 前半段是true，后半段是false，查找最靠右的true 形如：true true true false false 实例：对于降序数组，查找最后一个大于等于target的元素的下标 12345678int l = 0, r = n - 1;while(l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if(nums[mid] &gt;= target) l = mid + 1; else r = mid - 1;&#125;return r; 例题：34. 在排序数组中查找元素的第一个和最后一个位置 while判断条件始终是小于等于，l和r始终是mid往右/往左一步。需要最靠哪边的true，就返回哪边的指针，即靠左对应return l；靠右对应return r；在不确定返回l还是r时，可以举例子，模拟一下l和r最终的指向。 二分答案对于求极小值的极大值问题，通常可以转化为在有序数组中求最靠左/最靠右的true的问题，进而可以转化为二分查找问题。 例题：1760. 袋子里最少数目的球 给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。 你可以进行如下操作至多 maxOperations 次： 选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有正整数个球。 比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。 你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。 请你返回进行上述操作后的最小开销。 示例 1： 123456输入：nums = [9], maxOperations = 2输出：3解释：- 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -&gt; [6,3] 。- 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -&gt; [3,3,3] 。装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。 分析：随着开销的增大，操作数ops会减小，因此对开销进行二分，找到满足ops &lt;= maxOperations的最小开销，即最靠左的true。可以想象一个数组以开销为索引，其值前半段是false，后半段是true。 代码： 123456789101112131415161718class Solution &#123;public: int minimumSize(vector&lt;int&gt;&amp; nums, int maxOperations) &#123; int l = 1, r = *max_element(nums.begin(), nums.end()); while(l &lt;= r)&#123; int mid = (l + r) / 2; int sum = 0; for(auto&amp; num: nums) sum += (num - 1) / mid; if(sum &lt;= maxOperations) r = mid - 1; else l = mid + 1; &#125; return l; &#125;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://github.com/penciy/penciy.github.io/tag/%E7%AE%97%E6%B3%95/"}],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2024-04-01T15:21:01.019Z","updated":"2024-04-19T13:16:49.520Z","comments":true,"path":"posts/1243066710/","link":"","permalink":"https://github.com/penciy/penciy.github.io/posts/1243066710/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}