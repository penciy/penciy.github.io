{"meta":{"title":"铅笔芯小屋","subtitle":null,"description":"天天开心","author":"一只铅笔芯","url":"https://penciy.github.io"},"pages":[{"title":"分类","date":"2019-12-31T16:00:00.000Z","updated":"2023-07-04T16:09:32.000Z","comments":true,"path":"category/index.html","permalink":"https://penciy.github.io/category/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-12-31T16:00:00.000Z","updated":"2023-07-04T16:09:32.000Z","comments":false,"path":"about/index.html","permalink":"https://penciy.github.io/about/index.html","excerpt":"","text":"关于我 我是一个在命运长河里挣扎的小鱼，90后，目前是小白一枚。 虽然心中不甘，但是目前确实是 Worst One 。 目标是成为全栈工程师、系统架构师。虽然前路迷茫，但是我会一步一步往前走。 关于主题 Hexo - LiveForCode 主题是根据 BNDong 的博客样式复制过来的，其中也借鉴了 Hexo - NexT 主题的样式。可能这个主题还有很多不尽人意的地方，在后续的阶段我会不断地完善，如果有关于主题的相关问题，欢迎联系我。"},{"title":"赞赏","date":"2019-12-31T16:00:00.000Z","updated":"2023-07-04T16:09:32.000Z","comments":false,"path":"donate/index.html","permalink":"https://penciy.github.io/donate/index.html","excerpt":"","text":"如果喜欢我的博客，或者喜欢我的博客主题，可以考虑赞赏一下哦，非常感激！网站所需的服务器和 CDN 都是不小的开支，日常维护也需要大量精力。 你们的支持是我前进的最大动力！"},{"title":"留言板","date":"2019-12-31T16:00:00.000Z","updated":"2023-07-04T16:09:32.000Z","comments":true,"path":"comment/index.html","permalink":"https://penciy.github.io/comment/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-31T16:00:00.000Z","updated":"2023-07-04T16:09:32.000Z","comments":true,"path":"tag/index.html","permalink":"https://penciy.github.io/tag/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-12-31T16:00:00.000Z","updated":"2023-07-04T16:09:32.000Z","comments":false,"path":"friend/index.html","permalink":"https://penciy.github.io/friend/index.html","excerpt":"","text":"欢迎各位朋友前来交换友链，本站友链接受以下类型的网站： 个人博客 公益组织等非盈利性网站 不接受广告、商业性网站，特殊情况除外 如果你的网站 一个月以上无法正常访问 将会被移除。"}],"posts":[{"title":"logTrick","slug":"logTrick","date":"2024-07-27T13:11:24.000Z","updated":"2025-02-18T13:00:38.863Z","comments":true,"path":"posts/42749442322/","link":"","permalink":"https://penciy.github.io/posts/42749442322/","excerpt":"","text":"题目 3171. 找到按位或最接近 K 的子数组 - 力扣（LeetCode） 3097. 或值至少为 K 的最短子数组 II - 力扣（LeetCode） 方法 logTrick的核心思路即对于元素U，进行或操作/与操作的其中一种，最多只能增大/减小logU次。 遇到涉及子数组或运算/与运算的题目时，可以考虑采用logTrick思想进行优化。步骤如下： 定义数组nums和数组ops，其中nums为原始输入，当前遍历到的数组下标为ptr，则ops[i]表示nums[i:ptr-1]这段区间的所有元素的位运算结果； 容易发现对于或运算，ops数组中的右侧元素为左侧元素的子集；对于与运算，ops数组中左侧元素为右侧元素的子集； 在对当前元素nums[ptr]操作时，可以从ptr-1开始倒序枚举下标j： 对于或运算，当发现nums[ptr]是ops[j]的子集时，说明nums[ptr]也是ops[:j-1]的子集； 对于与运算，当发现ops[j]是nums[ptr]的子集时，说明ops[:j-1]也都是nums[ptr]的子集； 继续枚举并不会导致ops[j]的变化，因此可以停止枚举； 由于ops数组的每个元素最多只会增大/减小logU次，因此总的时间复杂度为O(nlogn) 实际情况中，可以原地维护ops数组，进一步优化空间。 代码 或操作 1234567891011int n = nums.length;int[] ors = new int[n];for(int i = 0;i &lt; n;++i)&#123; int num = nums[i]; ors[i] = nums[i]; // 得到了一个长度为1的子数组的或运算值ors[i] for(int j = i-1;j &gt;= 0 &amp;&amp; (ors[j] | num) != ors[j];--j)&#123; ors[j] |= num; // 得到了一个长度大于1的子数组的或运算值ors[j] &#125;&#125; 或操作（原地修改） 12345678for (int i = 0; i &lt; nums.length; i++) &#123; int x = nums[i]; // 得到了一个长度为1的子数组的或运算值 nums[i] for (int j = i - 1; j &gt;= 0 &amp;&amp; (nums[j] | x) != nums[j]; j--) &#123; nums[j] |= x; // 得到了一个长度大于1的子数组的或运算值nums[j] &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/tag/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}]},{"title":"快速幂--递归与迭代、数值与矩阵","slug":"快速幂--递归与迭代、数值与矩阵","date":"2024-07-22T07:01:24.000Z","updated":"2024-09-19T03:20:36.580Z","comments":true,"path":"posts/4232312342/","link":"","permalink":"https://penciy.github.io/posts/4232312342/","excerpt":"","text":"快速幂 递归求解 快速幂实际是分治的思想，把大的次幂一步步除以二。例如求解x17x^{17}x17，幂向下「递」的过程为：17-&gt;8-&gt;4-&gt;2-&gt;1，1即x本身，向上「归」即可得到结果。代码如下： 12345678public double pow(double x, long p)&#123; if(p == 0) return 1; if(p == 1) return x; double sub = pow(x, p/2); double ret = sub * sub; if(p % 2 == 1) ret *= x; return ret;&#125; 迭代求解 1234举例x^77，77的二进制数每一位都有相应的权值 1 0 0 1 1 0 1x^64 x^32 x^16 x^8 x^4 x^2 x^1最终结果就是所有二进制位为1的权值之积：x^1 * x^4 * x^8 * x^64 = x^77 可以通过上面的例子直观理解，其实就是把幂次转换为二进制，从低位开始遍历，同时维护xpx^{p}xp，其中ppp为2的幂，如果某个二进制位为1，将其对应的xpx^pxp累乘到结果。代码如下： 123456789public long pow(long x, int p)&#123; long ret = 1; while(p &gt; 0)&#123; if(p % 2 == 1) ret = ret * x % MOD; x = x * x % MOD; p &gt;&gt;= 1; &#125; return ret;&#125; 这里涉及到了另一个小知识点为快速幂取模，分治运算时顺便取下模就好了。 由于本质是把幂次转换为二进制，快速幂的时间复杂度为O(logn)。 矩阵快速幂 在求解某个矩阵matmatmat的幂时同样可以采用快速幂，因为矩阵乘法与数值乘法有类似的幂次分解性质。代码如下： 1234567891011121314151617181920212223public long[][] pow(long[][] mat, int n)&#123; long[][] ret = &#123;&#123;1, 0, 0, 0, 0, 0&#125;&#125;; while(n &gt; 0)&#123; if(n % 2 == 1) ret = multiply(ret, mat); mat = multiply(mat, mat); n /= 2; &#125; return ret;&#125;public long[][] multiply(long[][] a, long[][] b)&#123; int m1 = a.length, n1 = a[0].length; int m2 = b.length, n2 = b[1].length; long[][] c = new long[m1][n2]; for(int i = 0;i &lt; m1;++i)&#123; for(int j = 0;j &lt; n2;++j)&#123; for(int k = 0;k &lt; n1;++k)&#123; c[i][j] = (c[i][j] + a[i][k] * b[k][j] % MOD) % MOD; &#125; &#125; &#125; return c;&#125; 题目 50. Pow(x, n) - 力扣（LeetCode） 快速幂模板题 372. 超级次方 - 力扣（LeetCode） 快速幂取模 552. 学生出勤记录 II - 力扣（LeetCode） 用到了矩阵快速幂，但关键是得到需要幂运算的矩阵","categories":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/tag/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}]},{"title":"前缀函数-KMP-Z函数","slug":"前缀函数-KMP-Z函数","date":"2024-06-30T11:55:17.000Z","updated":"2024-09-19T03:19:36.133Z","comments":true,"path":"posts/321944572/","link":"","permalink":"https://penciy.github.io/posts/321944572/","excerpt":"","text":"前缀函数 (真)前缀/(真)后缀 前缀Prefix(S,i)Prefix(S,i)Prefix(S,i)是指从串首开始到某个位置iii结束的一个子串，即Prefix(S,i)=S[0..i]Prefix(S, i)=S[0..i]Prefix(S,i)=S[0..i]。真前缀指除了 SSS 本身的前缀。 后缀Suffix(S,i)Suffix(S,i)Suffix(S,i)是指从某个位置iii开始到字符串末尾的一个子串，即Suffix(S,i)=S[i..∣S∣−1]Suffix(S, i)=S[i..|S|-1]Suffix(S,i)=S[i..∣S∣−1]。真后缀指除了 SSS 本身的后缀。 前缀函数定义 给定一个长度为nnn的字符串sss，其前缀函数被定义为一个长度为nnn的数组π\\piπ。 其中π[i]\\pi [i]π[i]的定义是： 如果子串s[0...i]s[0...i]s[0...i]存在相等的真前缀与真后缀：s[0...k−1]s[0...k-1]s[0...k−1]和s[i−(k−1)...i]s[i-(k-1)...i]s[i−(k−1)...i]，那么π[i]\\pi[i]π[i]就是相等的真前缀的长度的最大值，即π[i]=max(k)\\pi[i] = max(k)π[i]=max(k)，否则π[i]=0\\pi[i] = 0π[i]=0； 特别地，规定π[0]=0\\pi[0] = 0π[0]=0。 例如字符串abaab，其前缀函数数组为[0,0,1,1,2][0,0,1,1,2][0,0,1,1,2]。 前缀函数计算方法 朴素的O(n3)O(n^3)O(n3)解法不再赘述，这里直接介绍一种O(n)O(n)O(n)复杂度的算法，也是下面介绍的KMP算法的基础。假设目前所求为next[i]next[i]next[i]，next[0..i−1]next[0..i-1]next[0..i−1]已全部计算完成。令j=next[i−1]j=next[i-1]j=next[i−1]，如下图所示： 尝试比较s[i]s[i]s[i]与s[j]s[j]s[j]是否相同： 若相同，则说明s[i]s[i]s[i]可以沿用前缀next[i−1]next[i-1]next[i−1]，即next[i]=next[i−1]+1next[i] = next[i-1]+1next[i]=next[i−1]+1; 若不同，循环尝试是否可以沿用前缀next[j−1]next[j-1]next[j−1]，直到s[i]s[i]s[i]与s[j]s[j]s[j]相同或jjj为0； 该算法只需要利用s[i]s[i]s[i]左侧的π\\piπ值，不需要进行任何字符串的比较，可以在O(n)O(n)O(n)时间内完成。代码如下所示： 1234567891011// 求字符串word的前缀函数数组public int[] getNext(String word)&#123; int[] next = new int[n]; for(int i = 1;i &lt; n;++i)&#123; int j = next[i-1]; while(j != 0 &amp;&amp; word.charAt(i) != word.charAt(j)) j = next[j-1]; if(word.charAt(i) == word.charAt(j)) ++j; next[i] = j; &#125; return next;&#125; KMP算法 核心思想 KMP常用于字符串匹配任务，例如找到模式串s2s2s2与主串s1s1s1的所有匹配的下标。常规的暴力匹配算法在每次失配时，都需要将指针移动到模式串的起始位置，最终的时间复杂度为O(∣s1∣∗∣s2∣)O(|s1| * |s2|)O(∣s1∣∗∣s2∣)。而如果先求出模式串的前缀函数，再进行匹配，时间复杂度就会大大降低。如下图所示： 令指针i,ji,ji,j分别指向主串和模式串，其中指针iii只可能向右，指针jjj则需要在失配时回溯。 如果发生了失配，已知前后缀相同的最长长度next[j−1]next[j-1]next[j−1]，那么指针jjj可以直接回溯到下标next[j−1]next[j-1]next[j−1]，也就是说跳过了模式串的前jjj个字符的匹配过程。 代码模板 12345678910111213141516171819202122// 返回主串s1所有可行的匹配起始点public List&lt;Integer&gt; strStr(String s1, String s2) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); int n = s1.length(), m = s2.length(); int[] next = new int[m]; for(int i = 1;i &lt; m;++i)&#123; int j = next[i-1]; while(j != 0 &amp;&amp; s2.charAt(i) != s2.charAt(j)) j = next[j-1]; if(s2.charAt(i) == s2.charAt(j)) ++j; next[i] = j; &#125; int j = 0; for(int i = 0;i &lt; n;++i)&#123; while(j != 0 &amp;&amp; s2.charAt(j) != s1.charAt(i)) j = next[j-1]; if(s2.charAt(j) == s1.charAt(i)) ++j; if(j == m) &#123; ans.add(i-m+1); j = next[j-1]; &#125; &#125; return ans;&#125; 题目 28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode） 3045. 统计前后缀下标对 II - 力扣（LeetCode） Z函数(扩展KMP) 定义 对于一个长度为nnn的字符串sss，定义函数z[i]z[i]z[i]表示s[0,n−1]s[0,n-1]s[0,n−1]和s[i,n−1]s[i,n-1]s[i,n−1]的最长公共前缀的长度。特别地，z[0]=0z[0]=0z[0]=0。 以下样例展示了不同字符串的Z函数： z(aaaaa)=[0,4,3,2,1]z(aaaaa)=[0,4,3,2,1]z(aaaaa)=[0,4,3,2,1] z(aaabaab)=[0,2,1,0,2,1,0]z(aaabaab)=[0,2,1,0,2,1,0]z(aaabaab)=[0,2,1,0,2,1,0] z(abacaba)=[0,0,1,0,3,0,1]z(abacaba)=[0,0,1,0,3,0,1]z(abacaba)=[0,0,1,0,3,0,1] 朴素算法 容易实现复杂度O(n2)O(n^2)O(n2)的算法： 12345678public int[] getZ(String s)&#123; int n = s.length(); int[] z = new int[n]; for(int i = 1;i &lt; n;++i)&#123; while(i+z[i] &lt; n &amp;&amp; s.charAt(z[i]) == s.charAt(i+z[i])) ++z[i]; &#125; return z;&#125; 线性算法 从1到n-1依次计算z[i]z[i]z[i]的值（z[0]=0z[0]=0z[0]=0）。在计算z[i]z[i]z[i]时，需要用到已经计算完成的z[0..i−1]z[0..i-1]z[0..i−1]。 对于i，称区间[i,i+z[i]−1][i, i+z[i]-1][i,i+z[i]−1]是iii的匹配段。在算法执行过程中，维护右端点最大的匹配段[l,r][l,r][l,r]。由定义可知，s[l,r]s[l,r]s[l,r]与前缀s[0,r−l]s[0,r-l]s[0,r−l]是相同的。初始时l=r=0l=r=0l=r=0。 算法流程如下，计算z[i]z[i]z[i]时： 若i&lt;=ri &lt;= ri&lt;=r，由s[l,r]=s[0,r−l]s[l,r]=s[0,r-l]s[l,r]=s[0,r−l]可得s[i,r]=s[i−l,r−l]s[i,r]=s[i-l,r-l]s[i,r]=s[i−l,r−l]。因此z[i]&gt;=min(z[i−l],r−i+1)z[i] &gt;= min(z[i-l], r-i+1)z[i]&gt;=min(z[i−l],r−i+1) 若z[i−l]&lt;r−i+1z[i-l]&lt;r-i+1z[i−l]&lt;r−i+1，则z[i]z[i]z[i]不可能超出s[i,r]s[i,r]s[i,r]范围，z[i]=z[i−l]z[i]=z[i-l]z[i]=z[i−l]。 若z[i−l]&gt;=r−i+1z[i-l]&gt;=r-i+1z[i−l]&gt;=r−i+1，此时z[i]z[i]z[i]超出了s[i,r]s[i,r]s[i,r]范围，令z[i]=r−i+1z[i]=r-i+1z[i]=r−i+1，然后暴力枚举直到z[i]z[i]z[i]无法扩展为止。 若i&gt;ri &gt; ri&gt;r，直接按照朴素算法求出此时的z[i]z[i]z[i] 求出z[i]z[i]z[i]后，若新的右边界i+z[i]−1i+z[i]-1i+z[i]−1大于rrr，更新[l,r][l,r][l,r]，即l=i,r=i+z[i]−1l=i,r=i+z[i]-1l=i,r=i+z[i]−1 这个过程其实有点像manacher算法，都是维护了此前可达的最右侧边界，然后利用该边界提供的信息快速跳转到某个位置。可以访问 这个网站 来看 Z 函数的模拟过程。 代码模板 1234567891011121314151617public int[] getZ(String s)&#123; int n = s.length(); int[] z = new int[n]; int l = 0, r = 0; for(int i = 1;i &lt; n;++i)&#123; if(i &lt;= r)&#123; if(z[i-l] &lt; r-i+1) z[i] = z[i-l]; else z[i] = r-i+1; &#125; while(i+z[i] &lt; n &amp;&amp; s.charAt(i+z[i]) == s.charAt(z[i])) ++z[i]; if(i+z[i]-1 &gt; r)&#123; l = i; r = i+z[i]-1; &#125; &#125; return z;&#125; 时间复杂度：O(n)O(n)O(n)，由代码可知zzz数组中每个位置最多被访问两次。 应用/题目 与前缀函数类似，Z函数可用于子串匹配问题，将原串s1s1s1和模式串s2s2s2拼接为s=s2+∗+s1s=s2+*+s1s=s2+∗+s1，其中*为分割符。求出sss的Z函数后，对于[∣s2∣..∣s∣−1][|s2|..|s|-1][∣s2∣..∣s∣−1]范围内的iii，若z[i]=∣s2∣z[i]=|s2|z[i]=∣s2∣，则找到了一个匹配下标iii。参考代码如下： 123456789101112131415161718192021public List&lt;Integer&gt; strStr(String s1, String s2) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); String s = s2 + &quot;*&quot; + s1; int n = s1.length(), m = s2.length(); int[] z = new int[n+m+1]; int l = 0, r = 0; for(int i = 1;i &lt; n+m+1;++i)&#123; if(i &lt;= r)&#123; if(z[i-l] &lt; r-i+1) z[i] = z[i-l]; else z[i] = r-i+1; &#125; while(i+z[i] &lt; n+m+1 &amp;&amp; s.charAt(i+z[i]) == s.charAt(z[i])) ++z[i]; if(i+z[i]-1 &gt; r)&#123; l = i; r = i+z[i]-1; &#125; // 判断是否匹配 if(i &gt; m &amp;&amp; z[i] == m) ans.add(i-m-1); &#125; return ans;&#125; 下面是一些Z函数相关的题目，大多数情况下如果可以使用Z函数，那么也可以使用KMP。 28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode） 3045. 统计前后缀下标对 II - 力扣（LeetCode） 3036. 匹配模式数组的子数组数目 II - 力扣（LeetCode） 3008. 找出数组中的美丽下标 II - 力扣（LeetCode） 2223. 构造字符串的总得分和 - 力扣（LeetCode） 3031. 将单词恢复初始状态所需的最短时间 II - 力扣（LeetCode） 1392. 最长快乐前缀 - 力扣（LeetCode） 参考 Z 函数（扩展 KMP） - OI Wiki (oi-wiki.org)","categories":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/tag/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}]},{"title":"差分、二维差分、树上差分","slug":"差分、二维差分、树上差分","date":"2024-06-14T10:05:24.000Z","updated":"2024-09-19T03:20:06.306Z","comments":true,"path":"posts/11231445/","link":"","permalink":"https://penciy.github.io/posts/11231445/","excerpt":"","text":"差分 概念 对于一个数组arr，如果要将长为m的区间内的所有元素增加 x，常规的做法是遍历进行操作，复杂度为O(m)，但如果这样的操作不是1次而是n次，则复杂度会变为O(mn)。如果要优化时间复杂度，可以借助差分数组进行： 例如，数组arr长为n，定义一个长为n+1的差分数组diff。将区间arr[l: r]中的元素增加x，等效于将diff[l]加上x，将diff[r]减去x后求前缀和。 题目 1094. 拼车 - 力扣（LeetCode） 代码 12345678910111213public boolean carPooling(int[][] trips, int capacity) &#123; int[] diff = new int[1001]; for(int[] trip: trips)&#123; diff[trip[1]] += trip[0]; diff[trip[2]] -= trip[0]; &#125; if(diff[0] &gt; capacity) return false; for(int i = 1;i &lt;= 1000;++i)&#123; diff[i] += diff[i-1]; if(diff[i] &gt; capacity) return false; &#125; return true;&#125; 二维差分 概念 下面推广至二维场景，即在一个二维数组中，将一个子矩阵的元素值全部增加某个值。与一维差分借助一维前缀和类似，二维差分需要借助二维前缀和的方法。假设要将mat中的一个子矩阵sub（四个边界用up、down、left、right表示）全部增加x，具体流程如下： 首先定义一个 m+1 * n +1 的二维差分数组diff 对于每次操作，将diff[up][left]与diff[down+1][right+1]增加 x，diff[up][right+1]与diff[down+1][left]减少 x 求二维前缀和，忽略右端/下端的列/行，结果即为操作后的mat矩阵 题目 2536. 子矩阵元素加 1 - 力扣（LeetCode） 代码 123456789101112131415161718public int[][] rangeAddQueries(int n, int[][] queries) &#123; int[][] diff = new int[n+1][n+1]; for(int[] q: queries)&#123; diff[q[0]][q[1]]++; diff[q[2]+1][q[3]+1]++; diff[q[0]][q[3]+1]--; diff[q[2]+1][q[1]]--; &#125; for(int i = 0;i &lt; n;++i) for(int j = 1;j &lt; n;++j) diff[i][j] += diff[i][j-1]; for(int i = 1;i &lt; n;++i) for(int j = 0;j &lt; n;++j) diff[i][j] += diff[i-1][j]; int[][] ans = new int[n][n]; for(int i = 0;i &lt; n;++i)&#123; for(int j = 0;j &lt; n;++j)&#123; ans[i][j] = diff[i][j]; &#125; &#125; return ans;&#125; 树上差分 概念 差分思想同样可以用在树上，考虑场景：把树上的一条路径上的节点计数值全部加1。从起点 x 到终点 y 的路径可以视作从 x 向上到某个点「拐弯」，再向下到达 y。 这个拐弯的点是 x 和 y 的 lca（最近公共祖先），因此需要配合LCA问题求解方法。注意拐弯的点也可能就是 x 或 y 本身。 设路径为 x−z−lca−y，其中 z 是 lca 往 x 方向的儿子。这条路径可以拆分成 x−z 和 y−lca 两段。 把路径上的点的计数加一，转换成对差分数组 diff 的两个数的更新。规定把下面的点加一，把上面的点减一： 对于 x−z，把 diff[x] 加一，diff[lca] 减一。注意，如果 x 就是 lca，那么 z 是不存在的，而差分操作刚好对 diff[x] 加一再减一，没有变化。所以我们无需特判 x 就是 lca 的情况。 对于 y−lca，把 diff[y] 加一，diff[father[lca]] 减一，其中 father[lca] 表示 lca 的父节点。 完成差分数组的求解后，DFS这棵树，在递归过程中自底向上累加即可得到最终的计数。 以上是点差分的算法，还有边差分的做法。举例说明：对于树上的路径x–y，路径上经过的点的数目应当使用点差分；而如果是经过的边数目，应当使用边差分。 由于在边上直接进行差分比较困难，所以将本来应当累加到边上的值向下移动到附近的点里，那么操作起来也就方便了。即：diff[x]++; diff[y]++ diff[lca]-=2; 题目 2646. 最小化旅行的价格总和 - 力扣（LeetCode） 参考 灵神（灵茶山艾府）题解 前缀和 &amp; 差分 - OI Wiki (oi-wiki.org)","categories":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/tag/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}]},{"title":"前缀和","slug":"前缀和","date":"2024-06-05T07:25:11.000Z","updated":"2024-09-19T03:19:02.565Z","comments":true,"path":"posts/qian_zhui_he/","link":"","permalink":"https://penciy.github.io/posts/qian_zhui_he/","excerpt":"","text":"前缀和 定义 前缀和可以简单理解为「数列的前 n 项的和」，可以O(1)地查询区间和，通常在数组不发生更新的情况下使用。 模板 1234int n = arr.length;int[] preSum = new int[n+1];for(int i = 0;i &lt; n;++i) preSum[i+1] = preSum[i] + arr[i]; // 预处理前缀和数组int sumL2R = preSum[r+1] - preSum[l]; // 计算arr[l:r]的和 二维/多维前缀和 二维前缀和定义 设矩阵为mat，二维前缀和数组为preSum，preSum[i][j]的含义可以表述为：从mat[0][0]到mat[i][j]（包含）这一个矩阵的元素总和。 模板 求解二维前缀和可以用容斥原理，如下所示： 1234567891011for(int i = 0;i &lt; n;i++)&#123; for(int j = 0;j &lt; n;j++)&#123; // 求二维前缀和 if(j &gt; 0 &amp;&amp; i &gt; 0) diff[i][j] = diff[i-1][j] + diff[i][j-1] - diff[i-1][j-1] + diff[i][j]; else if(i &gt; 0) diff[i][j] = diff[i-1][j] + diff[i][j]; else if(j &gt; 0) diff[i][j] = diff[i][j-1] + diff[i][j]; &#125;&#125; 当维数升高时，这种方法其复杂度较高。可以考虑基于DP的二维/多维前缀和，求法如下： 12for(int i = 0;i &lt; n;++i) for(int j = 1;j &lt; n;++j) diff[i][j] += diff[i][j-1];for(int i = 1;i &lt; n;++i) for(int j = 0;j &lt; n;++j) diff[i][j] += diff[i-1][j]; 树上前缀和 设sumisum_isumi​表示节点iii到根节点的权值总和 若是点权，x,yx,yx,y 路径上的和为sumx+sumy−sumlca−sumfalcasum_x+sum_y-sum_{lca}-sum_{fa_{lca}}sumx​+sumy​−sumlca​−sumfalca​​，其中最后一项的下标代表最近公共祖先的父亲节点； 若是边权，x,yx,yx,y 路径上的和为sumx+sumy−2∗sumlcasum_x+sum_y-2*sum_{lca}sumx​+sumy​−2∗sumlca​ 参考 前缀和 &amp; 差分 - OI Wiki (oi-wiki.org)","categories":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/tag/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}]},{"title":"线段树","slug":"线段树","date":"2024-05-27T13:11:24.000Z","updated":"2024-09-19T03:17:13.208Z","comments":true,"path":"posts/4274944572/","link":"","permalink":"https://penciy.github.io/posts/4274944572/","excerpt":"","text":"线段树（数组实现） 简介 线段树是一种用于处理区间查询和更新问题的数据结构。其关键思想在于使用树中的一个节点表示一个区间的信息，父节点表示的区间从中间位置划分为两个子节点表示的区间。用[l,r][l,r][l,r]表示要查询/更新的区间，[s,e][s,e][s,e]表示树中的某个节点表示的区间，当前者完全包括了后者时，说明本次操作可以直接通过对某个单一节点操作完成。在完成操作后，在递归的”归“过程中更新查询结果/父节点的信息，直到根节点。 可以直接用数组存储这棵树，根节点存储在下标1处，对于下标为id的当前节点，其左孩子的下标为2*id，右孩子的下标为2*id+1。 模板 为什么数组要开四倍空间：最理想情况即满二叉树时， 区间长度为1的叶子节点全部位于最底层，此时线段树中节点总数为2n−12n-12n−1；对于一般情况如上图，底层节点数应为大于等于n的最小的二次幂，总节点数应为: 2⌊log2n⌋+1∗2−12^{\\lfloor{log_2 n}\\rfloor + 1}*2-1 2⌊log2​n⌋+1∗2−1 基于数组的线段树实现如下，直接在已知原数组的基础上建立线段树（即单点更新）： 1234567891011121314int n = arr.length;int[] seg = new int[4*n];build(1, 1, n, arr); // 线段树的根节点下标以及arr的起始下标都为1public void build(int node, int l, int r, int[] arr)&#123; if(l == r)&#123; seg[node] = arr[l-1]; return; &#125; int m = (l+r) &gt;&gt; 1; build(2*node, l, m, arr); build(2*node+1, m+1, r, arr); seg[node] = Math.max(seg[2*node], seg[2*node+1]);&#125; 线段树（动态开点+懒更新） 简介 动态开点：对于数据分布比较稀疏的情况，基于数组的线段树可能会爆内存，这时可以使用Node形式实现线段树，采用动态开点策略，即只有要用到某节点时才新建该节点。 懒更新：懒更新策略即当树中节点表示的线段完全被当前操作区间包含时，无需继续向下递归，而是使用一个lazyMark将其标记，直到下方节点被真正使用时才使用lazyMark进行更新。如果线段树不采用懒更新策略，那么只有单点更新操作是O(logn)的，因为每次区间更新时，最坏的情况（例如更新根节点的值）需要遍历所有树中节点。 模板 以求区间最大值为例： 区间[l,r]代表要操作的区间，它在一次调用期间是永远不会被更改的 如果操作区间包含了当前区间[s,e]，那么更新/返回最大值 如果操作区间与当前区间的左半有交集，那么进入到左侧线段；如果与右半有交集，那么进入到右侧线段 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 线段树的Node形式实现，动态开点、懒更新 * 下面的算法实现的是区间最小值的维护和查询 */class Node &#123; int val = Integer.MAX_VALUE; int lazyMark = Integer.MAX_VALUE; Node left; Node right; Node()&#123;&#125; Node(int v)&#123; this.val = v; &#125;&#125;class SegTree &#123; public Node root = new Node(); // 查询区间[l, r]的最小值 int query(Node node, int l, int r, int s, int e)&#123; if(l &lt;= s &amp;&amp; e &lt;= r) return node.val; int m = (s+e)&gt;&gt;1, ret = Integer.MAX_VALUE; pushdown(node); if(l &lt;= m) ret = Math.min(ret, query(node.left, l, r, s, m)); if(m+1 &lt;= r) ret = Math.min(ret, query(node.right, l, r, m+1, e)); return ret; &#125; // 用v尝试更新区间[l, r]的最小值 void update(Node node, int l, int r, int s, int e, int v)&#123; if(l &lt;= s &amp;&amp; e &lt;= r)&#123; node.val = Math.min(node.val, v); node.lazyMark = Math.min(node.lazyMark, v); return; &#125; pushdown(node); int m = (s+e)&gt;&gt;1; if(l &lt;= m) update(node.left, l, r, s, m, v); if(m+1 &lt;= r) update(node.right, l, r, m+1, e, v); node.val = Math.min(node.left.val, node.right.val); &#125; void pushdown(Node node) &#123; // 检查左右子节点是否为 null，如果是，需要创建一个新的子节点。 if (node.left == null) node.left = new Node(); if (node.right == null) node.right = new Node(); if(node.lazyMark == Integer.MAX_VALUE) return; // 如果当前节点具有有效的 lazyMark 值，则将其传递给子节点。 node.left.val = Math.min(node.left.val, node.lazyMark); node.right.val = Math.min(node.right.val, node.lazyMark); node.left.lazyMark = Math.min(node.left.lazyMark, node.lazyMark); node.right.lazyMark = Math.min(node.right.lazyMark, node.lazyMark); node.lazyMark = Integer.MAX_VALUE; &#125;&#125; 线段树二分 在使用线段树得到了各个区间的信息后，可以利用这些信息进行二分。 例如本题2940. 找到 Alice 和 Bob 可以相遇的建筑 ，对于每个查询，查找满足 i &gt; L 且 heights[i] &gt; v的最小的下标 i ，这个查询可以使用线段树二分，线段树维护区间最大值，单次O(logn)的实现： 12345678910111213141516private int query(int o, int l, int r, int L, int v) &#123; if (v &gt;= mx[o]) &#123; // 最大值 &lt;= v，没法找到 &gt; v 的数 return 0; &#125; if (l == r) &#123; // 找到了 return l; &#125; int m = (l + r) / 2; if (L &lt;= m) &#123; int pos = query(o * 2, l, m, L, v); // 递归左子树 if (pos &gt; 0) &#123; // 找到了 return pos; &#125; &#125; return query(o * 2 + 1, m + 1, r, L, v); // 递归右子树&#125; 题单 §线段树（无区间更新） 子数组中占绝大多数的元素 2205 最长递增子序列 II 2280 找到 Alice 和 Bob 可以相遇的建筑 2327 线段树二分 以组为单位订音乐会的门票 2470 线段树二分 由单个字符重复的最长子字符串 2629 §Lazy 线段树（有区间更新） 完成所有任务的最少时间 2381 更新数组后处理求和查询 2398 奇妙序列 2476 有更简单的做法 子数组不同元素数目的平方和 II 2816 LCP 05. 发 LeetCoin LCP 27. 黑盒光线反射 § 动态开点线段树 部分题目也可以用珂朵莉树解决。 掉落的方块 Range 模块 我的日程安排表 I 我的日程安排表 II 我的日程安排表 III 矩形面积 II 统计区间中的整数数目 2222 达到末尾下标所需的最大跳跃次数","categories":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/tag/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}]},{"title":"乘法逆元","slug":"乘法逆元","date":"2024-05-03T07:41:23.000Z","updated":"2024-06-05T11:44:24.035Z","comments":true,"path":"posts/3215636925/","link":"","permalink":"https://penciy.github.io/posts/3215636925/","excerpt":"","text":"定义 设模数为m，对于一个整数a，如果存在另一个整数a−1(0&lt;a−1&lt;m)a^ {-1} (0 &lt; a^ {-1} &lt;m)a−1(0&lt;a−1&lt;m)，满足a∗a−1≡1( mod m)a*a^{-1}\\equiv 1(\\bmod m)a∗a−1≡1(modm)，则称a−1a^{-1}a−1是a的乘法逆元。 一个数有逆元的充分必要条件是gcd(a,m)=1gcd(a,m)=1gcd(a,m)=1，此时逆元唯一存在。 逆元的含义：模m意义下，1个数a如果有逆元x，那么除以a相当于乘以x。 如何求乘法逆元 1.m为质数 定义式可以转化为a∗a−1=km+1a*a^{-1}=km+1a∗a−1=km+1，即a−1∗a−k∗m=1a^{-1}*a-k*m=1a−1∗a−k∗m=1，根据裴蜀定理，gcd(a, m)=1，必然存在整数a−1a^{-1}a−1和k使得上式成立。 如果(a0−1,k0)(a_0^{-1}, k_0)(a0−1​,k0​)是一组解，那么(a0−1+cm,k0+ca),c∈Z(a_0^{-1}+cm, k_0+ca),c\\in Z(a0−1​+cm,k0​+ca),c∈Z都是上式的解。因此必然存在一组解中的a0−1a_0^{-1}a0−1​满足0&lt;a0−1&lt;m0&lt;a_0^{-1}&lt;m0&lt;a0−1​&lt;m，即为所求的a−1a^{-1}a−1。 可以使用费马小定理求a−1a^{-1}a−1，即 am−1≡1( mod m)a^{m-1}\\equiv1(\\bmod m) am−1≡1(modm) 进一步有 am−1a−1≡a−1⇔am−2aa−1≡a−1( mod m)⇔am−2≡a−1\\begin{aligned} &amp;a^{m-1}a^{-1}\\equiv a^{-1}\\\\ \\Leftrightarrow &amp;a^{m-2}aa^{-1}\\equiv a^{-1}(\\bmod m)\\\\ \\Leftrightarrow &amp;a^{m-2}\\equiv a^{-1} \\end{aligned} ⇔⇔​am−1a−1≡a−1am−2aa−1≡a−1(modm)am−2≡a−1​ 因此，a−1a^{-1}a−1就等于am−2a^{m-2}am−2对m取模的结果。计算am−2a^{m-2}am−2可以使用快速幂取模，在O(logm)O(logm)O(logm)时间内完成。 2.m不为质数 不管m是否为质数，都可以使用扩展欧几里得计算a−1a^{-1}a−1： 给定模数m，求解a−1⋅x≡1( mod m)a^{-1}\\cdot x \\equiv 1(\\bmod m)a−1⋅x≡1(modm)可以转化为a⋅x−m⋅y=1a\\cdot x - m\\cdot y=1a⋅x−m⋅y=1 然后可以套用求二元一次方程的方法，用扩展欧几里得算法求逆元，复杂度为O(logm)O(logm)O(logm)。 在使用扩展欧几里德算法求解逆元前，首先通过证明扩展欧几里得算法来对该算法有一个简单的理解： 引理：存在 x , y 使得 gcd(a,b)=ax+by 证明： 当 b=0 时，gcd(a,b)=a，此时 x=1 , y=0 当 b!=0 时， 设 ax1+by1=gcd(a,b)=gcd(b,a mod b)=bx2+(a mod b)y2ax1+by1=gcd(a,b)=gcd(b,a\\bmod b)=bx2+(a\\bmod b)y2ax1+by1=gcd(a,b)=gcd(b,amodb)=bx2+(amodb)y2 又因 a mod b=a−ab∗ba\\bmod b=a-\\frac{a}{b}*bamodb=a−ba​∗b ，可得： ax1+by1=bx2+(a−a/b∗b)y2ax1+by1=bx2+(a-a/b*b)y2ax1+by1=bx2+(a−a/b∗b)y2 ax1+by1=bx2+ay2−a/b∗by2ax1+by1=bx2+ay2-a/b*by2ax1+by1=bx2+ay2−a/b∗by2 ax1+by1=ay2+bx2−b∗a/b∗y2ax1+by1=ay2+bx2-b*a/b*y2ax1+by1=ay2+bx2−b∗a/b∗y2 ax1+by1=ay2+b(x2−a/b∗y2)ax1+by1=ay2+b(x2-a/b*y2)ax1+by1=ay2+b(x2−a/b∗y2) 解得 x1=y2x1=y2x1=y2 , y1=x2−a/b∗y2y1=x2-a/b*y2y1=x2−a/b∗y2 因此当 b=0 时存在 x , y 为最后一组解 而每一组的解可根据后一组得到 所以第一组的解 x , y 必然存在 根据上面的证明，在实现的时候采用递归做法 先递归进入下一层，等到到达最后一层即 b=0 时就返回x=1 , y=0 再根据x1=y2,y1=x2−a/b∗y2x1=y2 , y1=x2-a/b*y2x1=y2,y1=x2−a/b∗y2 ( x2 与 y2 为下一层的 x 与 y ) 得到当层的解 不断算出当层的解并返回，最终返回至第一层，得到原解 由于gcd(a, m)为1，引理转化为ax+by=1，可以使用扩展欧几里德算法求逆元，过程如下：求exgcd(a, m)—&gt;利用欧几里得算法不断递归直到x=1,y=0—&gt;反向递归求出第一层的x和y，x即为a在模m意义下的的逆元。 12345678910111213141516171819202122232425262728293031public static long exgcd(long a, long b, MyLong x, MyLong y) &#123; if(b == 0) &#123; x.v = 1; y.v = 0; return a; &#125; long gcd=exgcd(b, a%b, x, y); long c = y.v; y.v = x.v - (a/b)*y.v; x.v = c; return gcd;&#125;// 由于java没有指针，创建一个自定义类方便操作class MyLong&#123; long v; public MyLong() &#123;&#125;; public MyLong(long v) &#123; this.v=v; &#125;&#125;public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); long a = sc.nextLong(); long m = sc.nextLong(); MyLong y = new MyLong(); MyLong x = new MyLong(); long inv = (exgcd(a, m, x, y) == 1 ? (x.v % m + m) % m : -1); // 求a关于m的逆元&#125; 简单总结 乘法是遵循取模定理的，即(a×b) mod m=((a mod m)×(b mod m)) mod m(a\\times b) \\bmod m=((a\\bmod m)\\times (b\\bmod m)) \\bmod m(a×b)modm=((amodm)×(bmodm))modm，但是除法不遵循，计算a/b mod ma/b \\bmod ma/bmodm，不能对a和b分别取模再相除。要用乘法逆元，即ab≡a⋅b−1( mod m)\\frac{a}{b} \\equiv a\\cdot b^{-1}(\\bmod m)ba​≡a⋅b−1(modm)，把除法转化为模m乘法，然后就可以把a/b mod ma/b \\bmod ma/bmodm转化为$a*x \\bmod m $。 一般如果mmm是质数，求xxx可以用费马小定理，bm−2b^{m-2}bm−2就是xxx。求幂的时候需要用快速幂取模。 无论mmm是否为质数，都可以用扩展欧几里得算法计算逆元。 模板 求逆元多出现在组合数学，需要对答案取模的题目中，这种情况下一般需要求某些数关于模数m的逆元。 可以用递推的方式预处理出所有数的阶乘以及阶乘的逆元，如下代码所示： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; private static final int MOD = (int)1e9 + 7; private static final int MX = (int)1e5 + 1; // 组合数模板 static final long[] FAC = new long[MX]; // FAC[i]表示i! static final long[] INV_FAC = new long[MX]; // INV_FAC[i]表示i!在MOD下的逆元，即1/(i!) static&#123; FAC[0] = 1; for(int i = 1;i &lt; MX;++i)&#123; FAC[i] = FAC[i-1] * i % MOD; &#125; INV_FAC[MX-1] = myPow(FAC[MX-1], MOD-2); for(int i = MX-1;i &gt;= 1;--i)&#123; INV_FAC[i-1] = INV_FAC[i] * i % MOD; &#125; &#125; // 组合数公式，n个里面选k个 private static long comb(int n, int k)&#123; return FAC[n] % MOD * INV_FAC[n-k] % MOD * INV_FAC[k] % MOD; &#125; // 快速幂+取模 private static long myPow(long x, int p)&#123; long ret = 1; while(p &gt; 0)&#123; if(p % 2 == 1) ret = ret * x % MOD; x = x * x % MOD; p &gt;&gt;= 1; &#125; return ret; &#125;&#125; 题目 2954. 统计感冒序列的数目 - 力扣（LeetCode）(内有组合数学模板) 1916. 统计为蚁群构筑房间的不同顺序 - 力扣（LeetCode）","categories":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/tag/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}]},{"title":"Tarjan强连通分量、割点/割边","slug":"Tarjan强连通分量-割点-割边","date":"2024-04-12T12:19:32.000Z","updated":"2024-06-05T12:04:55.325Z","comments":true,"path":"posts/1828842990/","link":"","permalink":"https://penciy.github.io/posts/1828842990/","excerpt":"","text":"强连通分量 定义 强连通的定义是：有向图 G 强连通是指，G 中任意两个结点连通。 强连通分量（Strongly Connected Components，SCC）的定义是：极大的强连通子图，即彼此两两可达的节点集合。如下图，强连通分量可以表示为[[2, 3, 4, 5], [1], [6, 8, 9], [7]]。 算法 为每个节点维护两个变量： dfn：该节点被dfs最初访问到的时间 low：该节点能够通过其出边回溯到的最小时间 容易得到结论： 子树节点的dfn一定大于当前节点的dfn 从根节点开始的一条路径上，dfn严格递增，low严格非降 算法流程： 按照深度优先搜索算法搜索的次序对图中所有的结点进行搜索，维护每个结点的 dfn 与 low 变量，且让搜索到的结点入栈。每当找到一个强连通元素，就按照该元素包含结点数目让栈中元素出栈。在搜索过程中，对于结点u和与其相邻的结点v(v不是u的父节点)考虑 3 种情况： v未被访问：继续对v进行深度搜索。在回溯过程中，用low[v]更新 low[u]。因为存在从u到v的直接路径，所以v能够回溯到的已经在栈中的结点，u也一定能够回溯到。 v被访问过，已经在栈中：根据 low 值的定义，用low[v]更新low[u] 。 v被访问过，已不在栈中：说明v已搜索完毕，其所在连通分量已被处理，所以不用对其做操作。 一个连通分量有且仅有一个节点的dfn等于low。该节点一定是在深度遍历的过程中，该连通分量中第一个被访问过的节点，因为它的 dfn 和 low 值最小，不会被该连通分量中的其他结点所影响。因此在回溯的过程中如果dfn == low，说明该节点及栈中节点构成一个SCC。 注意如果原图并非无向连通图，需要在循环内多次调用tarjan，确保每个点都被访问到。 模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Tarjan求强连通分量板子// 全局变量int time = 1; // 当前时间戳Deque&lt;Integer&gt; stk = new ArrayDeque&lt;&gt;();int[] dfn; // 某节点被dfs访问到的时间int[] low; // 某节点能通过其出边回溯到的最早时间boolean[] inStack; // 节点是否在栈中，用于处理存在自环且除自环外无出边的点public List&lt;List&lt;Integer&gt;&gt; tarjan(List&lt;Integer&gt;[] g)&#123; int n = g.length; dfn = new int[n]; low = new int[n]; inStack = new boolean[n]; List&lt;List&lt;Integer&gt;&gt; ret = new ArrayList&lt;&gt;(); for(int i = 0;i &lt; n;++i) if(dfn[i] == 0) dfs(g, i, ret); return ret;&#125; public void dfs(List&lt;Integer&gt;[] g, int cur, List&lt;List&lt;Integer&gt;&gt; ret)&#123; dfn[cur] = time; low[cur] = time; ++time; stk.push(cur); inStack[cur] = true; for(int nxt: g[cur])&#123; if(dfn[nxt] == 0) &#123; dfs(g, nxt, ret); low[cur] = Math.min(low[cur], low[nxt]); &#125; else if(inStack[nxt])&#123; low[cur] = Math.min(low[cur], low[nxt]); &#125; &#125; // 当节点的low与dfn相等，说明它无法回溯到更早的时间点，它就是一个强连通分量的顶点 if(low[cur] == dfn[cur])&#123; List&lt;Integer&gt; ls = new ArrayList&lt;&gt;(); int top = -1; do&#123; top = stk.pop(); ls.add(top); inStack[top] = false; &#125;while(top != cur); ret.add(ls); &#125;&#125; 时间复杂度：O(V+E) 注：Tarjan求强连通分量适用于有向图，无向图的连通分量直接用并查集就行。 题目 802. 找到最终的安全状态 - 力扣（LeetCode）（本题Tarjan并非最优解法） 割点/割边 定义 割点：对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点。 割边：对于一个无向图，如果删掉一条边后图中的连通分量数增加了，则称这条边为桥或者割边。 算法 类似强连通分量。 割点判据有两条：1.根节点且有至少两个子树；2.非根节点且存在一个儿子nxt满足low[nxt] &gt;= dfn[cur]。 割边的判据只有一条：low[nxt] &gt; dfn[cur]，说明cur-nxt这条边是割边。 注意当发现已经访问过的节点时，需要用dfn[nxt]更新low[cur]，而不是像求解SCC时使用low[nxt]更新。 考虑无向图结构如下，从节点1出发，如果使用的是low[nxt]更新，会导致节点5和节点6的low被更新为1，算法会认为节点5和6不需要经过节点2就能回溯到更早的节点，进而认为节点2不是割点。 也就是说更新low[cur]时不能通过nxt的其它边继续回溯。 模板 适用于无向连通图 123456789101112131415161718192021222324252627282930313233343536373839404142434445int time = 1;int[] dfn;int[] low;List&lt;List&lt;Integer&gt;&gt; edges = new ArrayList&lt;&gt;();List&lt;Integer&gt; points = new ArrayList&lt;&gt;();Set&lt;Integer&gt; seenPoint = new HashSet&lt;&gt;();public void Tarjan(List&lt;Integer&gt;[] g)&#123; int n = g.length; dfn = new int[n]; low = new int[n]; dfs(g, 0, -1);&#125;public void dfs(List&lt;Integer&gt;[] g, int cur, int fa)&#123; dfn[cur] = time; low[cur] = time; time++; int sonCnt = 0; for(int nxt: g[cur])&#123; if(nxt == fa) continue; if(dfn[nxt] == 0)&#123; sonCnt++; dfs(g, nxt, cur); low[cur] = Math.min(low[cur], low[nxt]); // 割边判据1：low[nxt] &gt; dfn[cur]，则cur-nxt为割边 if(low[nxt] &gt; dfn[cur])&#123; List&lt;Integer&gt; edge = new ArrayList&lt;&gt;(); edge.add(cur); edge.add(nxt); edges.add(edge); &#125; // 割点判据1：cur非根节点，且存在一个孩子nxt满足low[nxt] &gt;= dfn[cur] if(seenPoint.contains(cur)) continue; if(fa != -1 &amp;&amp; low[nxt] &gt;= dfn[cur])&#123; points.add(cur); seenPoint.add(cur); &#125; &#125; else&#123; low[cur] = Math.min(low[cur], dfn[nxt]); // 注意这里不要用low[nxt]更新 &#125; // 割点判据2：cur为根节点，且存在至少两个子树 if(fa == -1 &amp;&amp; sonCnt &gt;= 2) points.add(cur); &#125;&#125; 缩点 定义：把连通分量看成是一个大点，保留那些不在强连通分量里的边，这样的图就是缩点后的图。 缩点后的图保留了所有不在分量里的边，而且对于有向连通图，缩点后的图是一个有向无环图(DAG)，可以进行拓扑排序。 题目 1192. 查找集群内的关键连接 - 力扣（LeetCode）----------割边 1489. 找到最小生成树里的关键边和伪关键边 - 力扣（LeetCode）----------割边、缩点 注意本题在缩点后的图中，是可能存在重复边的，因此不能用父节点作为continue的依据，而应该使用来路的那条边作为continue的依据","categories":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/tag/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"图论","permalink":"https://penciy.github.io/tag/%E5%9B%BE%E8%AE%BA/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}]},{"title":"LCA问题--树上倍增与Tarjan","slug":"LCA问题--树上倍增与Tarjan","date":"2024-04-07T13:11:24.000Z","updated":"2024-09-19T03:07:29.833Z","comments":true,"path":"posts/4274956372/","link":"","permalink":"https://penciy.github.io/posts/4274956372/","excerpt":"","text":"树上倍增 模板：1483. 树节点的第 K 个祖先 - 力扣（LeetCode） pa[i] [j]表示节点i的第2^j个祖先，时刻牢记外层循环为j，内层循环为i。 LCA问题： 预处理得到pa数组，pa[i] [j]表示节点i的第2^j个祖先; 求解x和y的最近公共祖先时，首先较深的节点(假设为y)转为与x相同的深度上，即y = getKthAncestor(depth[y] - depth[x])，如果此时x == y，那么x即为结果。 否则二者同步向上找，从节点数n的最高位开始遍历： 若pa[x] [i] == -1 || pa[x] [i] == pa[y] [i]，说明步子迈大了，继续循环 若pa[x] [i] != -1 &amp;&amp; pa[x] [i] != pa[y] [i]，说明lca还在上方，将x更新为 pa[x] [i] , y更新为 pa[y] [i]，将i减1继续循环。 上述做法能跳就尽量跳，不会错过任何可以上跳的机会。所以循环结束时，lca与x仅一步之遥。即lca = pa[x] [0]。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class TreeAncestor &#123; private int[] depth; private int[][] pa; public TreeAncestor(int[][] edges) &#123; int n = edges.length + 1; int m = 32 - Integer.numberOfLeadingZeros(n); // n 的二进制长度 List&lt;Integer&gt; g[] = new ArrayList[n]; Arrays.setAll(g, e -&gt; new ArrayList&lt;&gt;()); for (var e : edges) &#123; // 节点编号从 0 开始 int x = e[0], y = e[1]; g[x].add(y); g[y].add(x); &#125; depth = new int[n]; pa = new int[n][m]; dfs(g, 0, -1); for (int i = 0; i &lt; m - 1; i++) &#123; for (int x = 0; x &lt; n; x++) &#123; int p = pa[x][i]; pa[x][i + 1] = p &lt; 0 ? -1 : pa[p][i]; &#125; &#125; &#125; private void dfs(List&lt;Integer&gt;[] g, int x, int fa) &#123; pa[x][0] = fa; for (int y : g[x]) &#123; if (y != fa) &#123; depth[y] = depth[x] + 1; dfs(g, y, x); &#125; &#125; &#125; public int getKthAncestor(int node, int k) &#123; for (; k &gt; 0; k &amp;= k - 1) node = pa[node][Integer.numberOfTrailingZeros(k)]; return node; &#125; public int getLCA(int x, int y) &#123; if (depth[x] &gt; depth[y]) &#123; int tmp = y; y = x; x = tmp; &#125; // 使 y 和 x 在同一深度 y = getKthAncestor(y, depth[y] - depth[x]); if (y == x) return x; for (int i = pa[x].length - 1; i &gt;= 0; i--) &#123; int px = pa[x][i], py = pa[y][i]; if (px != py) &#123; x = px; y = py; &#125; &#125; return pa[x][0]; &#125;&#125; 时间复杂度：初始化O(NlogN), getLCA单次执行O(logN) 空间复杂度:O(NlogN) 题目：2846. 边权重均等查询 - 力扣（LeetCode） Tarjan 基于树上倍增的算法求LCA可以做到在线查询，但单次get的时间复杂度是O(logN)的。Tarjan算法可以线性复杂度、离线地求LCA，也就是说，需要一次性传入所有查询。 与求强连通分量、割点割边时不同，此时的Tarjan不需要保存访问到某个节点的时间戳，只需要用一个color数组表示该节点的递归过程即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class TreeAncester &#123; int[] color, root, ret; List&lt;Integer&gt;[] g; List&lt;int[]&gt;[] qs; TreeAncester(int n, int[][] edges)&#123; this.g = new List[n]; // 建图 this.qs = new List[n]; // 保存所有查询，包括其在查询数组中的下标 this.root = new int[n]; // 并查集的簇头节点 this.color = new int[n]; // Tarjan过程中的染色数组 Arrays.setAll(g, k-&gt;new ArrayList&lt;&gt;()); Arrays.setAll(qs, k-&gt;new ArrayList&lt;&gt;()); for(int i = 1;i &lt; n;++i) root[i] = i; for(int[] edge: edges) &#123; int u = edge[0], v = edge[1]; g[u].add(v); g[v].add(u); &#125; &#125; public void Tarjan(int cur, int fa)&#123; color[cur] = 1; // 正在递归 for(int nxt: g[cur])&#123; if(color[nxt] != 0) continue; // 这两句不能调换顺序，否则所有lca都会变成tarjan的入口节点 Tarjan(nxt, cur); root[nxt] = cur; // 相当于把 nxt 的子树节点全部 merge 到 cur &#125; for(int[] q: qs[cur])&#123; // color[y] == 2 意味着 y 所在子树已经遍历完 // 也就意味着 y 已经 merge 到它和 x 的 lca 上了 // 此时 find(y) 就是 x 和 y 的 lca int node = q[0], idx = q[1]; if(node == cur || color[node] == 2)&#123; int lca = find(node); ret[idx] = lca; &#125; &#125; color[cur] = 2; // 递归结束 &#125; // 并查集查找簇头 public int find(int x)&#123; return root[x] == x ? x : (root[x] = find(root[x])); &#125; // 离线传入所有的查询，返回结果 public int[] getLCAs(int[][] querys)&#123; int m = querys.length; this.ret = new int[m]; for(int i = 0;i &lt; m;++i)&#123; int[] query = querys[i]; int u = query[0], v = query[1]; qs[u].add(new int[]&#123;v, i&#125;); if(u != v) qs[v].add(new int[]&#123;u, i&#125;); &#125; Tarjan(0, -1); // 从根节点开始Tarjan return ret; &#125;&#125; 复杂度O(n+mα)，其中α为反阿克曼函数，可以认为是O(1) 题目：2646. 最小化旅行的价格总和 - 力扣（LeetCode）","categories":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/tag/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}]},{"title":"二分查找","slug":"二分查找","date":"2024-04-03T11:51:33.000Z","updated":"2024-04-21T14:45:45.121Z","comments":true,"path":"posts/3907716225/","link":"","permalink":"https://penciy.github.io/posts/3907716225/","excerpt":"","text":"二分查找 可以二分的前提：有序 时间复杂度：O(log n) 模板 目前只遇到了两种二分情况，基本可以包括所有二分的情景： 前半段是false，后半段是true，查找最靠左的true 形如：false false false false true true true 实例：对于升序数组，查找第一个大于等于target的元素的下标 12345678int l = 0, r = n - 1;while(l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if(nums[mid] &gt;= target) r = mid - 1; else l = mid + 1;&#125;return l; 前半段是true，后半段是false，查找最靠右的true 形如：true true true false false 实例：对于降序数组，查找最后一个大于等于target的元素的下标 12345678int l = 0, r = n - 1;while(l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if(nums[mid] &gt;= target) l = mid + 1; else r = mid - 1;&#125;return r; 例题：34. 在排序数组中查找元素的第一个和最后一个位置 while判断条件始终是小于等于，l和r始终是mid往右/往左一步。需要最靠哪边的true，就返回哪边的指针，即靠左对应return l；靠右对应return r；在不确定返回l还是r时，可以举例子，模拟一下l和r最终的指向。 二分答案 对于求极小值的极大值问题，通常可以转化为在有序数组中求最靠左/最靠右的true的问题，进而可以转化为二分查找问题。 例题：1760. 袋子里最少数目的球 给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。 你可以进行如下操作至多 maxOperations 次： 选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有正整数个球。 比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。 你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。 请你返回进行上述操作后的最小开销。 示例 1： 123456输入：nums = [9], maxOperations = 2输出：3解释：- 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -&gt; [6,3] 。- 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -&gt; [3,3,3] 。装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。 分析：随着开销的增大，操作数ops会减小，因此对开销进行二分，找到满足ops &lt;= maxOperations的最小开销，即最靠左的true。可以想象一个数组以开销为索引，其值前半段是false，后半段是true。 代码： 123456789101112131415161718class Solution &#123;public: int minimumSize(vector&lt;int&gt;&amp; nums, int maxOperations) &#123; int l = 1, r = *max_element(nums.begin(), nums.end()); while(l &lt;= r)&#123; int mid = (l + r) / 2; int sum = 0; for(auto&amp; num: nums) sum += (num - 1) / mid; if(sum &lt;= maxOperations) r = mid - 1; else l = mid + 1; &#125; return l; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/tag/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://penciy.github.io/category/%E7%AE%97%E6%B3%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-04-01T15:21:01.019Z","updated":"2024-04-19T13:16:49.520Z","comments":true,"path":"posts/1243066710/","link":"","permalink":"https://penciy.github.io/posts/1243066710/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}